##  Task 1: Getting Familiar with the Victim Smart Contract

### Task 1.a: Compiling the Contract

```bash
solc-0.6.8 --overwrite --abi --bin -o . ReentrancyVictim.sol

```

### Task 1.b: Deploying the Victim Contract

In this task, we will deploy the victim contract to the blockchain.
From the compilation before results the .bin file. The bin file contains the bytecode of
the contract. After a contract is deployed, the bytecode will be stored to the blockchain.

```bash

python3 deploy_victim_contract.py

```

The result of the deployment:

```bash

Sending tx ...
---------Deploying Contract ----------------
... Waiting for block
Transaction Hash: 0xf4e5ffab459d27cb0ffe02bdb01644ad166e485bf2113a05dfbcb09210c425b0
Transaction Receipt: AttributeDict({'blockHash': HexBytes('0x5732291509f979619244a5682b44b3540ca8b57ad6d0292b6f91dd38f8a30761'), 'blockNumber': 73, 'contractAddress': '0xaf98236bcb084ADc949f43d647eb4045260b31F3', 'cumulativeGasUsed': 282261, 'effectiveGasPrice': 1000058427, 'from': '0xA403f63AD02a557D5DDCBD5F5af9A7627C591034', 'gasUsed': 282261, 'logs': [], 'logsBloom': HexBytes('0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'), 'status': 1, 'to': None, 'transactionHash': HexBytes('0xf4e5ffab459d27cb0ffe02bdb01644ad166e485bf2113a05dfbcb09210c425b0'), 'transactionIndex': 0, 'type': 2})
Victim contract: 0xaf98236bcb084ADc949f43d647eb4045260b31F3


```

The output is the transaction receipt of your smart contract deployment. A transaction receipt is a data structure that contains information about the execution of a transaction on the blockchain. It includes the following fields:

•  blockHash: The hash of the block that contains the transaction.

•  blockNumber: The number of the block that contains the transaction.

•  contractAddress: The address of the smart contract that was deployed by the transaction.

•  cumulativeGasUsed: The total amount of gas used by all transactions in the same block as this transaction.

•  effectiveGasPrice: The gas price paid by the sender of the transaction.

•  from: The address of the sender of the transaction.

•  gasUsed: The amount of gas used by this transaction.

•  logs: An array of log entries generated by the smart contract execution.

•  logsBloom: A bloom filter for fast searching of log topics.

•  status: A flag indicating whether the transaction was successful (1) or reverted (0).

•  to: The address of the receiver of the transaction (None for contract creation).

•  transactionHash: The hash of the transaction.

•  transactionIndex: The index of the transaction in the block.

•  type: The type of the transaction (2 for EIP-1559 transactions).

We can use these fields to verify and inspect our smart contract deployment. For example, we can check the status field to see if our deployment was successful, or we can use the contractAddress field to interact with our smart contract. 

###  Task 1.c: Interacting with the Victim Contract

After deploying the contract, we will deposit money to this contract from some users’ accounts.

```python
#fund_victim_contract.py with the actual contract address obtained from the deployment step.

#Deposit 30 ethers


#!/bin/env python3
  
from web3 import Web3
import SEEDWeb3
import os

abi_file    = "../contract/ReentrancyVictim.abi"
victim_addr = '0xaf98236bcb084ADc949f43d647eb4045260b31F3'

# Connect to our geth node
web3 = SEEDWeb3.connect_to_geth_poa('http://10.150.0.71:8545')

# We use web3.eth.accounts[1] as the sender because it has more Ethers
sender_account = web3.eth.accounts[1]
web3.geth.personal.unlock_account(sender_account, "admin")

# Deposit Ethers to the victim contract
# The attacker will steal them in the attack later
contract_abi  = SEEDWeb3.getFileContent(abi_file)
amount = 30  # the unit is ether
contract = web3.eth.contract(address=victim_addr, abi=contract_abi)
tx_hash  = contract.functions.deposit().transact({ 
                    'from':  sender_account,
                    'value': Web3.to_wei(amount, 'ether')
                })
print("Transaction sent, waiting for the block ...")
tx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)
print("Transaction Receipt: {}".format(tx_receipt))

# print out the balance of my account and the entire contract
myBalance = contract.functions.getBalance(sender_account).call()
print("----------------------------------------------------------")
print("== My balance inside the contract:")
print("   {}: {}".format(sender_account, myBalance))
print("== Smart Contract total balance:")
print("   {}: {}".format(victim_addr, web3.eth.get_balance(victim_addr)))
print("----------------------------------------------------------")


```


Result:

```bash

----------------------------------------------------------
== My balance inside the contract:
   0xA403f63AD02a557D5DDCBD5F5af9A7627C591034: 30000000000000000000
== Smart Contract total balance:
   0xaf98236bcb084ADc949f43d647eb4045260b31F3: 30000000000000000000
----------------------------------------------------------


```


```python
#withdraw_victim_contract.py with the actual contract address obtained from the deployment step.

#Withdraw 5 ethers


#!/bin/env python3
  
from web3 import Web3
import SEEDWeb3
import os

abi_file    = "../contract/ReentrancyVictim.abi"
victim_addr = '0xaf98236bcb084ADc949f43d647eb4045260b31F3'

# Connect to our geth node
web3 = SEEDWeb3.connect_to_geth_poa('http://10.150.0.71:8545')

# We use web3.eth.accounts[1] as the sender because it has more Ethers
sender_account = web3.eth.accounts[1]
web3.geth.personal.unlock_account(sender_account, "admin")

# Deposit Ethers to the victim contract
# The attacker will steal them in the attack later
contract_abi  = SEEDWeb3.getFileContent(abi_file)
contract = web3.eth.contract(address=victim_addr, abi=contract_abi)
amount = 5
tx_hash  = contract.functions.withdraw(Web3.to_wei(amount, 'ether')).transact({
                    'from':  sender_account
                })
print("Transaction sent, waiting for the block ...")
tx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)
print("Transaction Receipt: {}".format(tx_receipt))

# print out the balance of my account and the entire contract
myBalance = contract.functions.getBalance(sender_account).call()
print("----------------------------------------------------------")
print("== My balance inside the contract:")
print("   {}: {}".format(sender_account, myBalance))
print("== Smart Contract total balance:")
print("   {}: {}".format(victim_addr, web3.eth.get_balance(victim_addr)))
print("----------------------------------------------------------")




```

Final result of the lab task is:

```bash

----------------------------------------------------------
== My balance inside the contract:
   0xA403f63AD02a557D5DDCBD5F5af9A7627C591034: 25000000000000000000
== Smart Contract total balance:
   0xaf98236bcb084ADc949f43d647eb4045260b31F3: 25000000000000000000
----------------------------------------------------------

```

As expected.

## Task 2: The Attacking Contract

To launch the reentrancy attack on the victim contract, the attacker needs to deploy an attack smart contract.


```bash

python3 deploy_attack_contract.py

```

```python

#deploy attack contract

#attack contract must know the address of the victim contract

#...

abi_file        = "../contract/ReentrancyAttacker.abi"
bin_file        = "../contract/ReentrancyAttacker.bin" 
victim_contract = '0xaf98236bcb084ADc949f43d647eb4045260b31F3'

#...


```


```bash

#Output deployment

---------Deploying Contract ----------------
... Waiting for block
Transaction Hash: 0xda16d5f650e0d1c87fd70572e584673d66d0ee1f4ead86247cb5354e5760bd9a
Transaction Receipt: AttributeDict({'blockHash': HexBytes('0x2a6c34e0f2c33135921a9ae61090fdc80e3c0f40429bcf8133c2be7414d240e6'), 'blockNumber': 248, 'contractAddress': '0x758a1930B1a2350F446f81f39E4D2E8e010227A2', 'cumulativeGasUsed': 356807, 'effectiveGasPrice': 1000000007, 'from': '0x9105A373ce1d01B517aA54205A5E4c70FA9f34Fe', 'gasUsed': 356807, 'logs': [], 'logsBloom': HexBytes('0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'), 'status': 1, 'to': None, 'transactionHash': HexBytes('0xda16d5f650e0d1c87fd70572e584673d66d0ee1f4ead86247cb5354e5760bd9a'), 'transactionIndex': 0, 'type': 2})
Attack contract: 0x758a1930B1a2350F446f81f39E4D2E8e010227A2

```

Reentrency Attack principles:



•  The attacker contract has a function called attack() that sends 1 ether to the victim contract and calls its deposit() function. This function increases the attacker's balance in the victim contract by 1 ether.

•  The attacker contract then calls the withdraw() function of the victim contract to get back the 1 ether. This function checks if the attacker has enough balance and then sends the 1 ether to the attacker using msg.sender.call().

•  However, msg.sender.call() also triggers the fallback() function of the attacker contract, which is a special function that runs when the contract receives money without a specific function call.

•  The fallback() function checks if the victim contract still has money and then calls its withdraw() function again. This creates a loop where the attacker keeps withdrawing 1 ether from the victim contract without reducing their balance.

•  The loop ends when the victim contract runs out of money or gas. The attacker can then keep all the money that they have withdrawn from the victim contract.



The main flaw in this attack is that the victim contract updates the balance of the sender after sending them money, instead of before. This allows the attacker to bypass the balance check and withdraw more money than they have deposited. A possible solution is to use transfer() instead of call() to send money, which does not trigger the fallback() function of the receiver. Another solution is to use a mutex or a reentrancy guard to prevent recursive calls to the same function.